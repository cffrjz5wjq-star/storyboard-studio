<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Storyboard Studio – Projekt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="styles.css" />

  <!-- Mammoth DOCX-Import -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>

  <style>
    /* Zusätzliche Styles, falls noch nicht in styles.css vorhanden */
    .hidden-col { display:none !important; }
    .row-selected { background:#fef3c7 !important; }
    tr.dragging { opacity:0.5; }
    tr.drag-over { outline:2px dashed #ff8a3c; }

    .lightbox {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.7);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1000;
    }
    .lightbox.hidden { display:none; }
    .lightbox-inner img {
      max-width:90vw; max-height:90vh;
      border-radius:8px;
    }

    .images-thumbs img {
      width:60px; height:auto;
      border-radius:4px;
      cursor:pointer;
      margin-right:4px;
    }
    .hidden-file { display:none; }
  </style>
</head>

<body>
<div class="app-shell">
  <div class="app project-app">

    <!-- Header -->
    <header class="project-header">
      <div class="header-left">
        <div class="logo-badge">SB</div>
        <div>
          <div class="header-title">Storyboard Studio</div>
          <div class="header-subtitle">Projekt bearbeiten</div>
        </div>
      </div>

      <div class="header-user">
        <span id="projectHeaderTitle"></span>
        <button onclick="window.location.href='index.html'" class="small secondary">Zurück</button>
      </div>
    </header>

    <!-- Inhalt -->
    <main class="project-main">

      <!-- Projekt-Metadaten -->
      <section class="card">
        <div class="card-header">
          <div>
            <div class="card-title" id="projTitle">Projekt</div>
            <div class="card-subtitle" id="projSubtitle"></div>
          </div>

          <div style="display:flex; gap:0.4rem;">
            <button id="btnDeleteProject" class="danger small">Projekt löschen / archivieren</button>
            <button id="btnSaveProject" class="primary small">Projekt speichern</button>
          </div>
        </div>

        <div class="project-meta-grid">
          <div>
            <span class="project-meta-label">Projektname</span>
            <input id="peTitle" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Redaktion</span>
            <input id="peEditor" type="text" />
          </div>
          <div>
            <span class="project-meta-label">CVD</span>
            <input id="peCvd" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Bereich</span>
            <input id="peArea" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Sendung</span>
            <input id="peShow" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Format</span>
            <input id="peFormat" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Kurzbeschreibung</span>
            <input id="peShort" type="text" />
          </div>
          <div>
            <span class="project-meta-label">Projekt-ID</span>
            <input id="peId" type="text" disabled />
          </div>
        </div>
      </section>

      <!-- Takes -->
      <section class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Drehbuch &amp; Takes</div>
            <div class="card-subtitle">
              Takes, Bilder, Sprechertexte und Timecodes bearbeiten. DOCX-Import möglich.
            </div>
          </div>

          <div class="toolbar-right">
            <button id="btnAddTake" class="small">+ neuer Take</button>
            <button id="btnDeleteSelected" class="small">Ausgewählte löschen</button>
            <button id="btnRecalcTc" class="small">Timecodes neu berechnen</button>
            <button id="btnExportPdf" class="small">Druck / PDF</button>
          </div>
        </div>

        <!-- Spalten-Toggles -->
        <div class="toolbar">
          <div class="column-toggle-bar">
            <strong>Spalten:</strong>
            <label><input type="checkbox" data-col-toggle="take" checked disabled> Take</label>
            <label><input type="checkbox" data-col-toggle="tcIn" checked> In</label>
            <label><input type="checkbox" data-col-toggle="tcOut" checked> Out</label>
            <label><input type="checkbox" data-col-toggle="camera" checked> Bild/Kamera</label>
            <label><input type="checkbox" data-col-toggle="speaker" checked> Sprechertext</label>
            <label><input type="checkbox" data-col-toggle="persons" checked> Personen</label>
            <label><input type="checkbox" data-col-toggle="notes" checked> Notizen</label>
            <label><input type="checkbox" data-col-toggle="music" checked> Musik</label>
            <label><input type="checkbox" data-col-toggle="source" checked> Herkunft</label>
            <label><input type="checkbox" data-col-toggle="images" checked> Bilder</label>
          </div>

          <div style="font-size:0.78rem;">
            <label><input type="checkbox" id="chkAutoRenumber" checked> Take-Nummern automatisch</label>
            <label><input type="checkbox" id="chkAutoTc" checked> Timecodes automatisch</label>
          </div>
        </div>

        <!-- DOCX Import -->
        <div class="field">
          <label for="docxFile">DOCX-Datei (Word) importieren</label>
          <div style="display:flex; gap:0.4rem;">
            <input id="docxFile" type="file" accept=".docx" />
            <button id="btnImportDocx" class="small">DOCX importieren</button>
          </div>
          <div id="docxInfo" class="muted" style="margin-top:0.3rem;">
            Tabellen mit Takes, Kameras, Sprechertext usw. werden automatisch erkannt.
          </div>
        </div>

        <!-- Tabelle -->
        <div class="table-wrapper">
          <table class="takes-table" id="takesTable">
            <thead>
              <tr>
                <th data-col="take">Take</th>
                <th data-col="tcIn">In</th>
                <th data-col="tcOut">Out</th>
                <th data-col="camera">Bild/Kamera</th>
                <th data-col="speaker">Sprechertext</th>
                <th data-col="persons">Personen</th>
                <th data-col="notes">Notizen</th>
                <th data-col="music">Musik</th>
                <th data-col="source">Herkunft</th>
                <th data-col="images">Bilder</th>
              </tr>
            </thead>
            <tbody id="takesBody"></tbody>
          </table>
        </div>

        <!-- Projektnotizen -->
        <div class="field" style="margin-top:0.6rem;">
          <label>Allgemeine Projekt-Notizen</label>
          <textarea id="projectNotes"></textarea>
        </div>

      </section>

    </main>
  </div>
</div>

<!-- Lightbox -->
<div id="lightbox" class="lightbox hidden">
  <div class="lightbox-inner">
    <img id="lightboxImg" src="" alt="" />
  </div>
</div>

<!-- Haupt-Editor-Logik -->
<script>
<script>
// =============================================
// Storyboard Studio – Projekt-Editor
// =============================================

// Konstante: Timecode-Basis
const TC_FPS = 25;

// Kleine Hilfsfunktionen
function $(id) { return document.getElementById(id); }

function loadJSON(key, fallback) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : fallback;
  } catch (e) {
    console.error("Fehler beim Lesen von", key, e);
    return fallback;
  }
}

function saveJSON(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}

function safeKey(str) {
  return String(str || "").toLowerCase().replace(/[^a-z0-9]+/g, "_");
}

// Timecode-Helfer
function parseTimecode(tc) {
  if (!tc) return 0;
  const parts = tc.split(":").map(Number);
  while (parts.length < 4) parts.unshift(0);
  const [h, m, s, f] = parts;
  return (((h * 60 + m) * 60) + s) * TC_FPS + f;
}

function formatTimecode(frames) {
  if (frames < 0) frames = 0;
  const f = frames % TC_FPS;
  let totalSeconds = (frames - f) / TC_FPS;
  const s = totalSeconds % 60;
  totalSeconds = (totalSeconds - s) / 60;
  const m = totalSeconds % 60;
  const h = (totalSeconds - m) / 60;
  const pad = n => String(n).padStart(2, "0");
  return `${pad(h)}:${pad(m)}:${pad(s)}:${pad(f)}`;
}

// Sehr grobe Dauer-Schätzung aus Sprechertext
function estimateDurationSeconds(text) {
  if (!text) return 0;
  const words = text.trim().split(/\s+/).length;
  const wps = 3.0; // Wörter pro Sekunde (ca.)
  return Math.ceil(words / wps);
}

// Globale Variablen für dieses Projekt
let currentProject = null;
let projectsKey = null;
let archiveKey = null;

// Session / User auslesen
function getCurrentUserEmail() {
  const session = loadJSON("sb_session", null);
  return session && session.email ? session.email : "local_guest";
}

// Projekte-Liste für diesen User
function loadProjectsForEditor() {
  if (!projectsKey) return [];
  return loadJSON(projectsKey, []);
}

function saveProjectsForEditor(list) {
  if (!projectsKey) return;
  saveJSON(projectsKey, list);
}

// Aktuelles Projekt im LocalStorage & Projektliste aktualisieren
function persistCurrentProject() {
  if (!currentProject) return;
  const list = loadProjectsForEditor();
  const idx = list.findIndex(p => p.id === currentProject.id);
  if (idx >= 0) {
    list[idx] = currentProject;
  } else {
    list.push(currentProject);
  }
  saveProjectsForEditor(list);
  saveJSON("sb_active_project", currentProject);
}

// Projekt aus LocalStorage initialisieren
function initProjectFromStorage() {
  const email = getCurrentUserEmail();
  projectsKey = "sb_projects_" + safeKey(email);
  archiveKey = projectsKey + "_archiv";

  let active = loadJSON("sb_active_project", null);
  const list = loadProjectsForEditor();

  if (!active && list.length) {
    active = list[0];
    saveJSON("sb_active_project", active);
  }

  if (!active) {
    active = {
      id: "tmp_" + Date.now().toString(36),
      title: "Unbenanntes Projekt",
      editor: "",
      cvd: "",
      area: "",
      show: "",
      format: "",
      shortDesc: "",
      notes: "",
      createdAt: new Date().toISOString(),
      takes: []
    };
  }

  currentProject = active;
  if (!Array.isArray(currentProject.takes)) currentProject.takes = [];

  hydrateUiFromProject();
}

// UI mit Projekt-Daten füllen
function hydrateUiFromProject() {
  const p = currentProject || {};

  $("peTitle").value  = p.title     || "";
  $("peEditor").value = p.editor    || "";
  $("peCvd").value    = p.cvd       || "";
  $("peArea").value   = p.area      || "";
  $("peShow").value   = p.show      || "";
  $("peFormat").value = p.format    || "";
  $("peShort").value  = p.shortDesc || "";
  $("peId").value     = p.id        || "";
  $("projectNotes").value = p.notes || "";

  $("projTitle").textContent = p.title || "Projekt";
  $("projectHeaderTitle").textContent = p.title || "";

  const metaParts = [];
  if (p.show) metaParts.push(p.show);
  if (p.format) metaParts.push(p.format);
  $("projSubtitle").textContent = metaParts.join(" · ");

  renderTakesTable();
}

// Projekt-Metadaten aus Formular zurück in Objekt
function syncProjectMetaFromUi() {
  if (!currentProject) return;
  const p = currentProject;
  p.title     = $("peTitle").value.trim();
  p.editor    = $("peEditor").value.trim();
  p.cvd       = $("peCvd").value.trim();
  p.area      = $("peArea").value.trim();
  p.show      = $("peShow").value.trim();
  p.format    = $("peFormat").value.trim();
  p.shortDesc = $("peShort").value.trim();
  p.notes     = $("projectNotes").value;
  p.updatedAt = new Date().toISOString();
}

// Tabelle der Takes rendern
function renderTakesTable() {
  const tbody = $("takesBody");
  tbody.innerHTML = "";

  const takes = currentProject && currentProject.takes ? currentProject.takes : [];

  takes.forEach((t, idx) => {
    const tr = document.createElement("tr");
    tr.dataset.index = idx;
    tr.draggable = true;

    tr.innerHTML = `
      <td data-col="take">
        <input type="text" data-field="take" data-index="${idx}" value="${t.take || (idx + 1)}">
      </td>
      <td data-col="tcIn">
        <input type="text" data-field="tcIn" data-index="${idx}" value="${t.tcIn || ""}" placeholder="00:00:00:00">
      </td>
      <td data-col="tcOut">
        <input type="text" data-field="tcOut" data-index="${idx}" value="${t.tcOut || ""}" placeholder="00:00:00:00">
      </td>
      <td data-col="camera">
        <textarea data-field="camera" data-index="${idx}">${t.camera || ""}</textarea>
      </td>
      <td data-col="speaker">
        <textarea data-field="speaker" data-index="${idx}">${t.speaker || ""}</textarea>
      </td>
      <td data-col="persons">
        <textarea data-field="persons" data-index="${idx}">${t.persons || ""}</textarea>
      </td>
      <td data-col="notes">
        <textarea data-field="notes" data-index="${idx}">${t.notes || ""}</textarea>
      </td>
      <td data-col="music">
        <textarea data-field="music" data-index="${idx}">${t.music || ""}</textarea>
      </td>
      <td data-col="source">
        <textarea data-field="source" data-index="${idx}">${t.source || ""}</textarea>
      </td>
      <td data-col="images">
        <div class="images-cell">
          <div class="images-thumbs" id="thumbs-${idx}"></div>
          <label class="small">
            <input type="file" accept="image/*" data-image-index="${idx}" class="hidden-file" multiple>
            Bilder wählen
          </label>
        </div>
      </td>
    `;

    // Klick zum Selektieren der Zeile
    tr.addEventListener("click", (e) => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.type === "file") return;
      tr.classList.toggle("row-selected");
    });

    // Drag & Drop
    tr.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", idx.toString());
      tr.classList.add("dragging");
    });
    tr.addEventListener("dragend", () => tr.classList.remove("dragging"));
    tr.addEventListener("dragover", (e) => {
      e.preventDefault();
      tr.classList.add("drag-over");
    });
    tr.addEventListener("dragleave", () => tr.classList.remove("drag-over"));
    tr.addEventListener("drop", (e) => {
      e.preventDefault();
      tr.classList.remove("drag-over");
      const fromIndex = parseInt(e.dataTransfer.getData("text/plain"), 10);
      const toIndex = idx;
      reorderTake(fromIndex, toIndex);
    });

    tbody.appendChild(tr);
  });

  // Inputs verbinden
  tbody.querySelectorAll("input[data-field], textarea[data-field]").forEach(el => {
    el.addEventListener("input", () => {
      const index = parseInt(el.dataset.index, 10);
      const field = el.dataset.field;
      const t = currentProject.takes[index];
      if (!t) return;
      t[field] = el.value;
      if (field === "speaker" && $("chkAutoTc").checked) {
        recalcTimecodes();
        renderTakesTable();
        persistCurrentProject();
      } else {
        persistCurrentProject();
      }
    });
  });

  // Bild-Upload
  tbody.querySelectorAll("input[data-image-index]").forEach(input => {
    input.addEventListener("change", handleImageUpload);
  });

  // Thumbnails rendern
  currentProject.takes.forEach((t, idx) => renderThumbnailsForTake(idx));

  // Spalten-Einstellungen anwenden
  applyColumnVisibilityFromToggles();
}

// Neuen leeren Take anhängen
function addEmptyTake() {
  if (!currentProject.takes) currentProject.takes = [];
  const idx = currentProject.takes.length;
  currentProject.takes.push({
    take: String(idx + 1),
    tcIn: "",
    tcOut: "",
    camera: "",
    speaker: "",
    persons: "",
    notes: "",
    music: "",
    source: "",
    images: []
  });
  renderTakesTable();
  persistCurrentProject();
}

// Ausgewählte Takes löschen
function deleteSelectedTakes() {
  const tbody = $("takesBody");
  const rows = Array.from(tbody.querySelectorAll("tr.row-selected"));
  if (!rows.length) {
    alert("Keine Takes ausgewählt.");
    return;
  }
  if (!confirm(`Wirklich ${rows.length} Take(s) löschen?`)) return;

  const indices = rows.map(r => parseInt(r.dataset.index, 10)).sort((a, b) => b - a);
  indices.forEach(i => currentProject.takes.splice(i, 1));

  if ($("chkAutoRenumber").checked) {
    currentProject.takes.forEach((t, i) => t.take = String(i + 1));
  }
  if ($("chkAutoTc").checked) {
    recalcTimecodes();
  }

  renderTakesTable();
  persistCurrentProject();
}

// Takes per Drag & Drop umsortieren
function reorderTake(from, to) {
  const arr = currentProject.takes;
  if (from === to) return;
  if (from < 0 || from >= arr.length || to < 0 || to >= arr.length) return;

  const [moved] = arr.splice(from, 1);
  arr.splice(to, 0, moved);

  if ($("chkAutoRenumber").checked) {
    arr.forEach((t, i) => t.take = String(i + 1));
  }
  if ($("chkAutoTc").checked) {
    recalcTimecodes();
  }

  renderTakesTable();
  persistCurrentProject();
}

// Timecodes neu berechnen
function recalcTimecodes() {
  const takes = currentProject.takes || [];
  let cursor = 0;

  takes.forEach(t => {
    const hasManualIn = t.tcIn && t.tcIn.trim().length > 0;
    const startFrames = hasManualIn ? parseTimecode(t.tcIn) : cursor;
    t.tcIn = formatTimecode(startFrames);

    const durSec = estimateDurationSeconds(t.speaker || "");
    const durFrames = durSec * TC_FPS;
    const endFrames = startFrames + durFrames;

    t.tcOut = formatTimecode(endFrames);
    cursor = endFrames;
  });
}

// DOCX in HTML umwandeln und passende Takes erzeugen
function parseDocxHtmlToTakes(html) {
  const container = document.createElement("div");
  container.innerHTML = html;

  const tables = container.querySelectorAll("table");
  const takes = [];

  if (tables.length) {
    tables.forEach(table => {
      const rows = table.querySelectorAll("tr");
      rows.forEach((row, idx) => {
        const cells = Array.from(row.querySelectorAll("th,td")).map(c => c.textContent.trim());
        const joined = cells.join("").trim();
        if (!joined) return;

        // Kopfzeile überspringen
        if (idx === 0 && /take|sprecher/i.test(joined)) return;

        // Mapping (einfach, aber praxistauglich):
        // 0: Take / lfd. Nr
        // 1: Bild/Kamera
        // 2: Sprechertext
        // 3: Personen
        // 4: Notizen
        // 5: Musik
        // 6: Herkunft
        const t = {
          take: cells[0] || String(takes.length + 1),
          tcIn: "",
          tcOut: "",
          camera: cells[1] || "",
          speaker: cells[2] || "",
          persons: cells[3] || "",
          notes: cells[4] || "",
          music: cells[5] || "",
          source: cells[6] || "",
          images: []
        };
        takes.push(t);
      });
    });
  } else {
    // Fallback: Absätze als einzelne Takes verwenden
    const paras = container.querySelectorAll("p");
    paras.forEach(p => {
      const text = p.textContent.trim();
      if (!text) return;
      takes.push({
        take: String(takes.length + 1),
        tcIn: "",
        tcOut: "",
        camera: "",
        speaker: text,
        persons: "",
        notes: "",
        music: "",
        source: "",
        images: []
      });
    });
  }
  return takes;
}

// DOCX-Datei importieren
function handleDocxImport() {
  const file = $("docxFile").files && $("docxFile").files[0];
  if (!file) {
    $("docxInfo").textContent = "Bitte zuerst eine DOCX-Datei auswählen.";
    $("docxInfo").style.color = "#b91c1c";
    return;
  }

  $("docxInfo").textContent = "DOCX wird verarbeitet …";
  $("docxInfo").style.color = "#6b7280";

  const reader = new FileReader();
  reader.onload = (e) => {
    const arrayBuffer = e.target.result;
    mammoth.convertToHtml({ arrayBuffer }).then(result => {
      const html = result.value || "";
      const imported = parseDocxHtmlToTakes(html);
      if (!imported.length) {
        $("docxInfo").textContent = "Keine verwertbaren Tabellen oder Texte gefunden.";
        $("docxInfo").style.color = "#b91c1c";
        return;
      }

      currentProject.takes = (currentProject.takes || []).concat(imported);

      if ($("chkAutoRenumber").checked) {
        currentProject.takes.forEach((t, i) => t.take = String(i + 1));
      }
      if ($("chkAutoTc").checked) {
        recalcTimecodes();
      }

      renderTakesTable();
      persistCurrentProject();

      $("docxInfo").textContent = `${imported.length} Takes importiert.`;
      $("docxInfo").style.color = "#15803d";
    }).catch(err => {
      console.error(err);
      $("docxInfo").textContent = "Fehler beim Lesen der DOCX-Datei.";
      $("docxInfo").style.color = "#b91c1c";
    });
  };
  reader.readAsArrayBuffer(file);
}

// Spalten ein-/ausblenden
function applyColumnVisibilityFromToggles() {
  const table = $("takesTable");
  if (!table) return;

  document.querySelectorAll("[data-col-toggle]").forEach(cb => {
    const col = cb.getAttribute("data-col-toggle");
    const visible = cb.checked;
    table.querySelectorAll(`[data-col="${col}"]`).forEach(cell => {
      cell.classList.toggle("hidden-col", !visible);
    });
  });
}

// Bilder-Upload
function handleImageUpload(e) {
  const input = e.target;
  const idx = parseInt(input.dataset.imageIndex, 10);
  const files = Array.from(input.files || []);
  if (!files.length) return;

  const take = currentProject.takes[idx];
  if (!take.images) take.images = [];

  const maxSlots = 4;
  const remaining = maxSlots - take.images.length;
  const toUse = files.slice(0, remaining);

  toUse.forEach(file => {
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        const dataUrl = resizeImageTo1920x1080(img);
        take.images.push(dataUrl);
        renderThumbnailsForTake(idx);
        persistCurrentProject();
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  });
}

// Bild auf max. 1920x1080 skalieren
function resizeImageTo1920x1080(img) {
  const maxW = 1920;
  const maxH = 1080;
  let { width, height } = img;
  const ratio = Math.min(maxW / width, maxH / height);
  width = Math.round(width * ratio);
  height = Math.round(height * ratio);

  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width, height);
  return canvas.toDataURL("image/jpeg", 0.9);
}

// Thumbnails rendern
function renderThumbnailsForTake(idx) {
  const take = currentProject.takes[idx];
  const container = $("thumbs-" + idx);
  if (!container) return;
  container.innerHTML = "";

  if (!take.images) return;
  take.images.slice(0, 4).forEach((src, i) => {
    const img = document.createElement("img");
    img.src = src;
    img.alt = "Bild " + (i + 1);
    img.addEventListener("click", () => openLightbox(src));
    container.appendChild(img);
  });
}

// Lightbox öffnen & schließen
function openLightbox(src) {
  $("lightboxImg").src = src;
  $("lightbox").classList.remove("hidden");
}

// Export der aktuellen Ansicht als Druck/PDF (Browserdruck)
function exportCurrentViewToPdf() {
  const toggles = document.querySelectorAll("[data-col-toggle]");
  const visibleCols = Array.from(toggles)
    .filter(t => t.checked)
    .map(t => t.getAttribute("data-col-toggle"));

  const labels = {
    take: "Take",
    tcIn: "In",
    tcOut: "Out",
    camera: "Bild/Kamera",
    speaker: "Sprechertext",
    persons: "Personen",
    notes: "Notizen",
    music: "Musik",
    source: "Herkunft",
    images: "Bilder"
  };

  const p = currentProject;
  const takes = p.takes || [];

  const head = visibleCols.map(c => `<th>${labels[c] || c}</th>`).join("");

  const rows = takes.map(t => {
    const tds = visibleCols.map(c => {
      if (c === "images") {
        const count = (t.images || []).length;
        return `<td>${count ? count + " Bild(er)" : ""}</td>`;
      }
      let v = "";
      if (c === "take") v = t.take || "";
      else if (c === "tcIn") v = t.tcIn || "";
      else if (c === "tcOut") v = t.tcOut || "";
      else v = t[c] || "";
      v = String(v).replace(/</g, "&lt;").replace(/\r?\n/g, "<br>");
      return `<td>${v}</td>`;
    }).join("");
    return `<tr>${tds}</tr>`;
  }).join("");

  const tableHtml = `
    <table>
      <thead><tr>${head}</tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;

  const w = window.open("", "_blank");
  const title = p.title || "Storyboard";

  w.document.write(`
    <!DOCTYPE html>
    <html lang="de">
    <head>
      <meta charset="UTF-8">
      <title>${title}</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
          font-size: 11px;
          margin: 20px;
          color: #111827;
        }
        h1 { font-size: 18px; margin-bottom: 4px; }
        h2 { font-size: 13px; margin-top: 12px; margin-bottom: 4px; }
        table { border-collapse: collapse; width: 100%; font-size: 10px; }
        th, td { border: 1px solid #9ca3af; padding: 3px 4px; vertical-align: top; }
        th { background: #e5e7eb; }
        .notes { font-size: 10px; margin-top: 8px; white-space: pre-wrap; }
      </style>
    </head>
    <body>
      <h1>${title}</h1>
      <div>${p.show || ""} ${p.format ? "· " + p.format : ""}</div>
      <h2>Takes</h2>
      ${tableHtml}
      ${p.notes ? `<div class="notes"><strong>Projekt-Notizen:</strong><br>${String(p.notes).replace(/</g, "&lt;").replace(/\r?\n/g, "<br>")}</div>` : ""}
    </body>
    </html>
  `);
  w.document.close();
  w.focus();
  w.print();
}

// Projekt löschen / archivieren
function deleteOrArchiveProject() {
  if (!currentProject) return;
  if (!confirm("Projekt ins Archiv verschieben und aus der aktiven Liste entfernen?")) return;

  const list = loadProjectsForEditor();
  const idx = list.findIndex(p => p.id === currentProject.id);
  if (idx >= 0) {
    const [proj] = list.splice(idx, 1);
    proj.archivedAt = new Date().toISOString();
    saveProjectsForEditor(list);

    const archList = loadJSON(archiveKey, []);
    archList.push(proj);
    saveJSON(archiveKey, archList);
  }

  // aktives Projekt zurücksetzen
  localStorage.removeItem("sb_active_project");
  alert("Projekt wurde ins Archiv verschoben.");
  window.location.href = "index.html";
}

// Events verbinden
function setupEvents() {
  $("btnSaveProject").addEventListener("click", () => {
    syncProjectMetaFromUi();
    persistCurrentProject();
    alert("Projekt gespeichert.");
  });

  $("btnAddTake").addEventListener("click", addEmptyTake);
  $("btnDeleteSelected").addEventListener("click", deleteSelectedTakes);

  $("btnRecalcTc").addEventListener("click", () => {
    recalcTimecodes();
    renderTakesTable();
    persistCurrentProject();
  });

  $("btnImportDocx").addEventListener("click", handleDocxImport);
  $("btnExportPdf").addEventListener("click", exportCurrentViewToPdf);

  $("btnDeleteProject").addEventListener("click", deleteOrArchiveProject);

  document.querySelectorAll("[data-col-toggle]").forEach(cb => {
    cb.addEventListener("change", applyColumnVisibilityFromToggles);
  });

  $("lightbox").addEventListener("click", () => {
    $("lightbox").classList.add("hidden");
    $("lightboxImg").src = "";
  });
}

// Initialisierung
document.addEventListener("DOMContentLoaded", () => {
  initProjectFromStorage();
  setupEvents();
});
</script>
</script>

</body>
</html>
